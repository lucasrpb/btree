Index: .idea/libraries/sbt__org_scala_lang_modules_scala_xml_2_12_1_0_6_jar.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/libraries/sbt__org_scala_lang_modules_scala_xml_2_12_1_0_6_jar.xml	(date 1530758091000)
+++ .idea/libraries/sbt__org_scala_lang_modules_scala_xml_2_12_1_0_6_jar.xml	(date 1530758091000)
@@ -0,0 +1,11 @@
+<component name="libraryTable">
+  <library name="sbt: org.scala-lang.modules:scala-xml_2.12:1.0.6:jar">
+    <CLASSES>
+      <root url="jar://$USER_HOME$/.ivy2/cache/org.scala-lang.modules/scala-xml_2.12/bundles/scala-xml_2.12-1.0.6.jar!/" />
+    </CLASSES>
+    <JAVADOC />
+    <SOURCES>
+      <root url="jar://$USER_HOME$/.ivy2/cache/org.scala-lang.modules/scala-xml_2.12/srcs/scala-xml_2.12-1.0.6-sources.jar!/" />
+    </SOURCES>
+  </library>
+</component>
\ No newline at end of file
Index: .idea/libraries/sbt__org_scala_lang_scala_reflect_2_12_6_jar.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/libraries/sbt__org_scala_lang_scala_reflect_2_12_6_jar.xml	(date 1530758091000)
+++ .idea/libraries/sbt__org_scala_lang_scala_reflect_2_12_6_jar.xml	(date 1530758091000)
@@ -0,0 +1,11 @@
+<component name="libraryTable">
+  <library name="sbt: org.scala-lang:scala-reflect:2.12.6:jar">
+    <CLASSES>
+      <root url="jar://$USER_HOME$/.sbt/boot/scala-2.12.6/lib/scala-reflect.jar!/" />
+    </CLASSES>
+    <JAVADOC />
+    <SOURCES>
+      <root url="jar://$USER_HOME$/.ivy2/cache/org.scala-lang/scala-reflect/srcs/scala-reflect-2.12.6-sources.jar!/" />
+    </SOURCES>
+  </library>
+</component>
\ No newline at end of file
Index: .idea/libraries/sbt__org_scalactic_scalactic_2_12_3_0_5_jar.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/libraries/sbt__org_scalactic_scalactic_2_12_3_0_5_jar.xml	(date 1530758091000)
+++ .idea/libraries/sbt__org_scalactic_scalactic_2_12_3_0_5_jar.xml	(date 1530758091000)
@@ -0,0 +1,11 @@
+<component name="libraryTable">
+  <library name="sbt: org.scalactic:scalactic_2.12:3.0.5:jar">
+    <CLASSES>
+      <root url="jar://$USER_HOME$/.ivy2/cache/org.scalactic/scalactic_2.12/bundles/scalactic_2.12-3.0.5.jar!/" />
+    </CLASSES>
+    <JAVADOC />
+    <SOURCES>
+      <root url="jar://$USER_HOME$/.ivy2/cache/org.scalactic/scalactic_2.12/srcs/scalactic_2.12-3.0.5-sources.jar!/" />
+    </SOURCES>
+  </library>
+</component>
\ No newline at end of file
Index: .idea/libraries/sbt__org_scalatest_scalatest_2_12_3_0_5_jar.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/libraries/sbt__org_scalatest_scalatest_2_12_3_0_5_jar.xml	(date 1530758091000)
+++ .idea/libraries/sbt__org_scalatest_scalatest_2_12_3_0_5_jar.xml	(date 1530758091000)
@@ -0,0 +1,11 @@
+<component name="libraryTable">
+  <library name="sbt: org.scalatest:scalatest_2.12:3.0.5:jar">
+    <CLASSES>
+      <root url="jar://$USER_HOME$/.ivy2/cache/org.scalatest/scalatest_2.12/bundles/scalatest_2.12-3.0.5.jar!/" />
+    </CLASSES>
+    <JAVADOC />
+    <SOURCES>
+      <root url="jar://$USER_HOME$/.ivy2/cache/org.scalatest/scalatest_2.12/srcs/scalatest_2.12-3.0.5-sources.jar!/" />
+    </SOURCES>
+  </library>
+</component>
\ No newline at end of file
Index: .idea/hydra.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/hydra.xml	(date 1530758021000)
+++ .idea/hydra.xml	(date 1530758021000)
@@ -0,0 +1,9 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="HydraSettings">
+    <option name="hydraStorePath" value="$PROJECT_DIR$/.hydra/idea" />
+    <option name="noOfCores" value="2" />
+    <option name="projectRoot" value="$PROJECT_DIR$" />
+    <option name="sourcePartitioner" value="auto" />
+  </component>
+</project>
\ No newline at end of file
Index: .idea/vcs.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/vcs.xml	(date 1530758021000)
+++ .idea/vcs.xml	(date 1530758021000)
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="VcsDirectoryMappings">
+    <mapping directory="$PROJECT_DIR$" vcs="Git" />
+  </component>
+</project>
\ No newline at end of file
Index: src/main/scala/btree/Block.scala
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/scala/btree/Block.scala	(date 1530758021000)
+++ src/main/scala/btree/Block.scala	(date 1530758021000)
@@ -0,0 +1,18 @@
+package btree
+
+trait Block[T, K, V] {
+
+  val MIN: Int
+  val MAX: Int
+
+  var parent: Option[MetaBlock[T, K, V]] = None
+
+  var pos: Int = 0
+  var size: Int = 0
+
+  def isFull() = size == MAX
+  def hasEnoughKeys() = size > MIN
+  def hasMinimumKeys() = size >= MIN
+  def isEmpty() = size == 0
+
+}
Index: src/main/scala/btree/DataBlock.scala
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/scala/btree/DataBlock.scala	(date 1530758021000)
+++ src/main/scala/btree/DataBlock.scala	(date 1530758021000)
@@ -0,0 +1,99 @@
+package btree
+
+import scala.reflect.ClassTag
+
+class DataBlock[T: ClassTag, K: ClassTag, V: ClassTag](val id: T,
+                                                       override val MIN: Int,
+                                                       override val MAX: Int)
+                                                      /*(implicit val comp: Ordering[K])*/
+  extends Block[T, K, V]{
+
+  val keys = Array.ofDim[(K, V)](MAX)
+  var next: Option[DataBlock[T, K, V]] = None
+  var prev: Option[DataBlock[T, K, V]] = None
+
+  override def isFull() = size == MAX
+
+  def find(key: K, start: Int = 0, end: Int = size - 1)(implicit comp: Ordering[K]): (Boolean, Int) = {
+    if(start > end) return false -> start
+
+    val pos = start + (end - start)/2
+    val k = keys(pos)._1
+    val c = comp.compare(key, k)
+
+    if(c == 0) return true -> pos
+    if(c < 0) return find(key, start, pos - 1)(comp)
+
+    find(key, pos + 1, end)
+  }
+
+  def insert(idx: Int, key: (K, V)): Boolean = {
+    for(i<-(size until idx by -1)){
+      keys(i) = keys(i-1)
+    }
+
+    keys(idx) = key
+
+    size += 1
+
+    true
+  }
+
+  def insert(key: (K, V))(implicit comp: Ordering[K]): Boolean = {
+    if(isFull()) return false
+
+    val r = find(key._1)(comp)
+
+    if(r._1) return false
+
+    insert(r._2, key)
+  }
+
+  def remove(idx: Int): Boolean = {
+    size -= 1
+
+    for(i<-idx until size){
+      keys(i) = keys(i+1)
+    }
+
+    true
+  }
+
+  def removeByKey(key: K)(implicit comp: Ordering[K]): Boolean = {
+    val r = find(key)(comp)
+
+    if(!r._1) return false
+    remove(r._2)
+  }
+
+  def removeAndGet(idx: Int): (K, V) = {
+    val key = keys(idx)
+    remove(idx)
+    key
+  }
+
+  def left: Option[DataBlock[T, K, V]] = {
+    parent match {
+      case None => None
+      case Some(parent) =>
+        val idx = pos - 1
+        if(idx >= 0) Some(parent.pointers(idx).asInstanceOf[DataBlock[T, K, V]]) else None
+    }
+  }
+
+  def right: Option[DataBlock[T, K, V]] = {
+    parent match {
+      case None => None
+      case Some(parent) =>
+        val idx = pos + 1
+
+        if(idx <= parent.size) Some(parent.pointers(idx).asInstanceOf[DataBlock[T, K, V]]) else None
+
+    }
+  }
+
+  def inOrder: Seq[K] = keys.slice(0, size).map(_._1)
+
+  override def toString = s"""[${keys.slice(0, size).map(_._1).mkString(",")}]"""
+
+}
Index: src/main/scala/btree/Index.scala
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/scala/btree/Index.scala	(date 1530758021000)
+++ src/main/scala/btree/Index.scala	(date 1530758021000)
@@ -0,0 +1,584 @@
+package btree
+
+import java.util.UUID
+
+import scala.reflect.ClassTag
+
+class Index[T:ClassTag, K: ClassTag, V: ClassTag](val DATA_ORDER: Int, val META_ORDER: Int)
+                                                 (implicit val comp: Ordering[K]) {
+
+  val DATA_MIN = DATA_ORDER - 1
+  val DATA_MAX = DATA_ORDER*2 - 1
+  val DATA_MIDDLE = DATA_MIN
+
+  val META_MIN = META_ORDER - 1
+  val META_MAX = META_ORDER*2 - 1
+  val META_MIDDLE = META_MIN
+
+  var root: Option[Block[T, K, V]] = None
+
+  protected def find(key: K,
+                     start: Option[Block[T, K, V]],
+                     parent: Option[MetaBlock[T, K, V]] = None,
+                     pos: Int = 0)(comp: Ordering[K]): Option[DataBlock[T, K, V]] = {
+    if(start.isEmpty) return None
+
+    start.get match {
+      case leaf: DataBlock[T, K, V] =>
+        Some(leaf)
+
+      case meta: MetaBlock[T, K, V] =>
+        val (start, idx) = meta.findPath(key)(comp)
+        find(key, Some(start), Some(meta), idx)(comp)
+    }
+  }
+
+  def find(key: K)(implicit comp: Ordering[K]): Option[DataBlock[T, K, V]] = {
+    find(key, root)(comp)
+  }
+
+  protected def splitMetaBlock(k: K, left: MetaBlock[T, K, V], prev: Block[T, K, V]): Boolean = {
+
+    val right = new MetaBlock[T, K, V](UUID.randomUUID.toString, META_MIN, META_MAX)
+
+    val keys = left.keys
+    val pointers = left.pointers
+    val up = keys(META_MIDDLE)
+
+    var j = 0
+
+    for(i<-META_MIDDLE+1 until META_MAX){
+      right.keys(j) = keys(i)
+      right.size += 1
+
+      right.setChild(j, pointers(i))
+
+      left.size -= 1
+
+      j += 1
+    }
+
+    // Excludes the middle key!
+    left.size -= 1
+
+    right.setChild(j, pointers(META_MAX))
+
+    val c = comp.compare(k, up)
+
+    if(c < 0){
+      left.insertRight(k, prev)
+    } else {
+      right.insertRight(k, prev)
+    }
+
+    handleParent(up, left, right)
+  }
+
+  protected def handleParent(k: K, left: Block[T, K, V], right: Block[T, K, V]): Boolean = {
+    left.parent match {
+      case None =>
+
+        val block = new MetaBlock[T, K, V](UUID.randomUUID.toString, META_MIN, META_MAX)
+
+        block.keys(0) = k
+        block.size += 1
+
+        block.setChild(0, left)
+        block.setChild(1, right)
+
+        val ROOT = Some(block)
+
+        root = ROOT
+
+        true
+
+      case Some(parent) =>
+
+        if(parent.isFull){
+          splitMetaBlock(k, parent, right)
+        } else {
+          parent.insertRight(k, right)
+        }
+
+    }
+  }
+
+  protected def splitDataBlock(left: DataBlock[T, K, V], k: K, v: V): Boolean = {
+
+    val right = new DataBlock[T, K, V](UUID.randomUUID.toString.asInstanceOf[T], DATA_MIN, DATA_MAX)
+    val keys = left.keys
+    val (middle, _) = keys(DATA_MIDDLE)
+
+    val c = comp.compare(k, middle)
+
+    val pos = if(c < 0) DATA_MIDDLE else DATA_MIDDLE + 1
+
+    var j = 0
+
+    for(i<-pos until DATA_MAX){
+      right.keys(j) = keys(i)
+      right.size += 1
+      left.size -= 1
+      j += 1
+    }
+
+    if(c < 0) left.insert(k -> v) else right.insert(k -> v)
+
+    // Pointers handling...
+    right.next = left.next
+    right.prev = Some(left)
+    left.next = Some(right)
+
+    if(left.next.isDefined){
+      left.next.get.prev = Some(right)
+    }
+
+    handleParent(keys(left.size - 1)._1, left, right)
+  }
+
+  protected def checkFull(leaf: DataBlock[T, K, V], k: K, v: V): Boolean = {
+    if(leaf.isFull()){
+
+     /* if(leaf.parent.isDefined && leaf.parent.get.isFull){
+        return false
+      }*/
+
+      return splitDataBlock(leaf, k, v)
+    }
+
+    leaf.insert(k -> v)
+  }
+
+  def insert(k: K, v: V)(implicit comp: Ordering[K]): Boolean = {
+    find(k)(comp) match {
+      case None =>
+
+        val leaf = new DataBlock[T, K, V](UUID.randomUUID.toString.asInstanceOf[T], DATA_MIN, DATA_MAX)
+        leaf.insert(0, k -> v)
+        root = Some(leaf)
+
+        true
+
+      case Some(leaf) =>
+
+        val (found, _) = leaf.find(k)
+
+        if(found) {
+          false
+        } else {
+          checkFull(leaf, k, v)
+        }
+
+    }
+  }
+
+  protected def merge(left: DataBlock[T, K, V], right: DataBlock[T, K, V]): DataBlock[T, K, V] = {
+    var j = left.size
+    val size = right.size
+
+    for(i<-0 until size){
+      left.keys(j) = right.keys(i)
+      left.size += 1
+      j += 1
+    }
+
+    // Fixing some pointers...
+    val next = right.next
+
+    left.next = next
+
+    if(next.isDefined){
+      next.get.prev = Some(left)
+    }
+
+    left
+  }
+
+  protected def merge(left: MetaBlock[T, K, V], right: MetaBlock[T, K, V], key: K): MetaBlock[T, K, V] = {
+    left.insert(key)
+
+    var j = left.size
+    val size = right.size
+    val keys = right.keys
+    val pointers = right.pointers
+
+    for(i<-0 until size){
+      left.keys(j) = keys(i)
+      left.size += 1
+
+      left.setChild(j, pointers(i))
+
+      j += 1
+    }
+
+    left.setChild(j, pointers(size))
+
+    left
+  }
+
+  protected def merge(target: MetaBlock[T, K, V], pos: Int, left: Option[MetaBlock[T, K, V]],
+                      right: Option[MetaBlock[T, K, V]]): Boolean = {
+
+    val parent = target.parent.get
+
+    target.remove(pos)
+
+    val merged = left match {
+      case Some(left) =>
+        merge(left, target, parent.keys(left.pos))
+      case _ => merge(target, right.get, parent.keys(target.pos))
+    }
+
+    // Parent is root :)
+    if(parent.parent.isEmpty){
+
+      parent.remove(merged.pos)
+
+      if(parent.isEmpty){
+        merged.parent = None
+        root = Some(merged)
+      }
+
+      return true
+    }
+
+    if(parent.hasEnoughKeys){
+      return parent.remove(merged.pos)
+    }
+
+    borrowFromLeft(parent, merged.pos)
+  }
+
+  protected def borrowFromRight(target: MetaBlock[T, K, V], pos: Int,
+                                left: Option[MetaBlock[T, K, V]]): Boolean = {
+    target.right match {
+      case None => merge(target, pos, left, None)
+      case Some(right) =>
+
+        val parent = target.parent.get
+
+        if(right.hasEnoughKeys()){
+
+          // Get the subtree of sibling's first key
+          val link = right.pointers(0)
+
+          /*
+           * The first key from sibling goes up to the parent's separating key position similarly to
+           * the left borrowing process
+           */
+          val up = right.removeRight(0)
+
+          // Parent's separating key goes down
+          val down = parent.keys(target.pos)
+
+          // New separating key on the parent
+          parent.keys(target.pos) = up
+
+          // Usual removal
+          target.remove(pos)
+
+          // Subtree inserted on the right of descending key.
+          target.insertRight(down, link)
+
+          true
+
+        } else {
+          merge(target, pos, left, Some(right))
+        }
+
+    }
+  }
+
+  protected def borrowFromLeft(target: MetaBlock[T, K, V], pos: Int): Boolean = {
+    target.left match {
+      case None => borrowFromRight(target, pos, None)
+      case Some(left) =>
+
+        val parent = target.parent.get
+
+        if(left.hasEnoughKeys()){
+
+          // Get the subtree of sibling's last key
+          val link = left.pointers(left.size)
+
+          /*
+           * On meta blocks we cannot duplicate keys. Parent's separating key must come down to the node where
+           * removing was performed and borrowing key must come up to the parent as the new separating key.
+          */
+          val up = left.removeAndGet(left.size - 1)
+
+          val down = parent.keys(left.pos)
+
+          parent.keys(left.pos) = up
+
+          // Usual removal
+          target.remove(pos)
+
+          /*
+           * The last subtree of the left sibling contains elements lower than the parent's separating key
+           * that came down. So it must be inserted on the left of that key.
+           */
+          target.insertLeft(down, link)
+
+          true
+        } else {
+          borrowFromRight(target, pos, Some(left))
+        }
+
+    }
+  }
+
+  protected def merge(target: DataBlock[T, K, V], pos: Int, left: Option[DataBlock[T, K, V]],
+                      right: Option[DataBlock[T, K, V]]): Boolean = {
+
+    println(s"\nMERGING...\n")
+
+    val parent = target.parent.get
+
+    // Usual deletion
+    target.remove(pos)
+
+    // Try to merge with leftmost node
+    val merged = left match {
+      case Some(left) =>
+        merge(left, target)
+
+      case None =>
+        merge(target, right.get)
+    }
+
+    // Parent is root
+    if(parent.parent.isEmpty){
+      parent.remove(merged.pos)
+
+      // Merged leaf is now the root...
+      if(parent.isEmpty()){
+        merged.parent = None
+        root = Some(merged)
+      }
+
+      return true
+    }
+
+    // Parent has enough keys
+    if(parent.hasEnoughKeys()){
+      return parent.remove(merged.pos)
+    }
+
+    // Parent doesn't have enough keys! We need to try to borrow. Here we go again...
+    borrowFromLeft(parent, merged.pos)
+  }
+
+  protected def borrowFromRight(target: DataBlock[T, K, V], pos: Int,
+                                left: Option[DataBlock[T, K, V]]): Boolean = {
+    target.right match {
+
+      // No right sibling either! We need to perform a merging operation
+      case None => merge(target, pos, left, None)
+      case Some(right) =>
+
+        val parent = right.parent.get
+
+        if(right.hasEnoughKeys()){
+
+          println(s"\nBORROWING FROM RIGHT DATA BLOCK...\n")
+
+          target.remove(pos)
+
+          // Borrow the first key from right sibling
+          target.insert(right.removeAndGet(0))
+
+          // Duplicate the new last key in the parent
+          parent.keys(target.pos) = target.keys(target.size - 1)._1
+
+          true
+
+        } else {
+
+          //No enough keys to borrow. We need to merge
+          merge(target, pos, left, Some(right))
+        }
+
+    }
+  }
+
+  protected def borrowFromLeft(target: DataBlock[T, K, V], pos: Int): Boolean = {
+    target.left match {
+      // No left sibling. Try to borrow from right one...
+      case None => borrowFromRight(target, pos, None)
+      case Some(left) =>
+
+        val parent = left.parent.get
+
+        // Has the sibling block enough keys so it can borrow one?
+        if(left.hasEnoughKeys()){
+
+          println(s"\nBORROWING FROM LEFT DATA BLOCK...\n")
+
+          // Perform the usual deletion operation...
+          target.remove(pos)
+
+          // Borrow the last key from the sibling
+          target.insert(left.removeAndGet(left.size - 1))
+
+          // On data blocks borrowing we duplicate the new last key from the sibling
+          parent.keys(left.pos) = left.keys(left.size - 1)._1
+
+          true
+
+        } else {
+
+          // No enough keys to borrow. Try to borrow from the right sibling (if any)
+          borrowFromRight(target, pos, Some(left))
+        }
+
+    }
+  }
+
+  protected def checkEnoughKeys(target: DataBlock[T, K, V], pos: Int): Boolean = {
+
+    // Is the leaf also the root?
+    if(target.parent.isEmpty){
+
+      // We can safely remove from the root even it not having enough keys!
+      target.remove(pos)
+
+      // The root is empty. No more data => empty tree!
+      if(target.isEmpty){
+        root = None
+      }
+
+      return true
+    }
+
+    // Block is a data block with sufficient keys...
+    if(target.hasEnoughKeys()){
+      return target.remove(pos)
+    }
+
+    // No enough keys. Try to borrow from left sibling...
+    borrowFromLeft(target, pos)
+  }
+
+  def remove(k: K)(implicit comp: Ordering[K]): Boolean = {
+
+    find(k)(comp) match {
+      case None => false
+      case Some(leaf) =>
+
+        val (found, pos) = leaf.find(k)
+
+        if(found){
+          checkEnoughKeys(leaf, pos)
+        } else {
+          // Key not present in the tree
+          false
+        }
+
+    }
+  }
+
+  protected def inOrder(start: Block[T, K, V], list: scala.collection.mutable.ArrayBuffer[K]): Unit = {
+    start match {
+      case data: DataBlock[T, K, V] =>
+
+       // println(s"\nblock: ${data}\n")
+
+        list ++= data.inOrder
+
+      case meta: MetaBlock[T, K, V] =>
+
+        val size = meta.size
+        val pointers = meta.pointers
+
+        //println(s"\nmeta: ${meta}\n")
+
+        for(i<-0 to size){
+          inOrder(pointers(i), list)
+        }
+
+    }
+  }
+
+  def inOrder(): scala.collection.mutable.ArrayBuffer[K] = {
+    val list = scala.collection.mutable.ArrayBuffer[K]()
+
+    /*root match {
+      case None => list
+      case Some(root) =>
+        inOrder(root, list)
+        list
+    }*/
+
+    var aux: Option[Block[T, K, V]] = root
+    var stop = false
+
+    while(!stop && aux.isDefined){
+      aux.get match {
+        case block: MetaBlock[T, K, V] => aux = Some(block.pointers(0))
+        case block: DataBlock[T, K, V] =>
+          aux = Some(block)
+          stop = true
+      }
+    }
+
+    var start: Option[DataBlock[T, K, V]] = aux.asInstanceOf[Option[DataBlock[T, K, V]]]
+
+    while(start.isDefined){
+      list ++= start.get.inOrder
+
+      val next = start.get.next
+      start = next
+    }
+
+    list
+  }
+
+  def prettyPrint(): Unit = {
+
+    val levels = scala.collection.mutable.Map[Int, scala.collection.mutable.ArrayBuffer[Block[T, K, V]]]()
+
+    def inOrder(start: Block[T, K, V], level: Int): Unit = {
+
+      val opt = levels.get(level)
+      var l: scala.collection.mutable.ArrayBuffer[Block[T, K, V]] = null
+
+      if(opt.isEmpty){
+        l = scala.collection.mutable.ArrayBuffer[Block[T, K, V]]()
+        levels  += level -> l
+      } else {
+        l = opt.get
+      }
+
+      start match {
+        case data: DataBlock[T, K, V] =>
+          l += data
+
+        case meta: MetaBlock[T, K, V] =>
+
+          l += meta
+
+          val size = meta.size
+          val pointers = meta.pointers
+
+          for(i<-0 to size){
+            inOrder(pointers(i), level + 1)
+          }
+
+      }
+    }
+
+    root match {
+      case Some(root) => inOrder(root, 0)
+      case _ =>
+    }
+
+    levels.keys.toSeq.sorted.foreach { case level =>
+        println(s"level[$level]: ${levels(level)}")
+    }
+
+    println()
+
+  }
+
+}
Index: src/main/scala/btree/MetaBlock.scala
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/main/scala/btree/MetaBlock.scala	(date 1530758021000)
+++ src/main/scala/btree/MetaBlock.scala	(date 1530758021000)
@@ -0,0 +1,166 @@
+package btree
+
+import scala.reflect.ClassTag
+
+class MetaBlock[T: ClassTag, K: ClassTag, V: ClassTag](val id: String,
+                                                       override val MIN: Int,
+                                                       override val MAX: Int)
+                                                      /*(implicit val comp: Ordering[K])*/
+  extends Block[T, K, V] {
+
+  val keys = Array.ofDim[K](MAX)
+  val pointers = Array.ofDim[Block[T, K, V]](MAX + 1)
+
+  def find(key: K, start: Int = 0, end: Int = size - 1)(implicit comp: Ordering[K]): (Boolean, Int) = {
+    if(start > end) return false -> start
+
+    val pos = start + (end - start)/2
+    val k = keys(pos)
+    val c = comp.compare(key, k)
+
+    if(c == 0) return true -> pos
+    if(c < 0) return find(key, start, pos - 1)(comp)
+
+    find(key, pos + 1, end)
+  }
+
+  def findPath(key: K)(implicit comp: Ordering[K]): (Block[T, K, V], Int) = {
+    val (_, pos) = find(key, 0, size-1)(comp)
+    pointers(pos) -> pos
+  }
+
+  def setChild(idx: Int, child: Block[T, K, V]): Unit = {
+    child.parent = Some(this)
+    child.pos = idx
+    pointers(idx) = child
+  }
+
+  def insert(key: K)(implicit comp: Ordering[K]): Boolean = {
+    if(isFull) return false
+    insert(find(key)(comp)._2, key)
+  }
+
+  protected def insert(idx: Int, key: K): Boolean = {
+    for(i<-(size until idx by -1)){
+      keys(i) = keys(i-1)
+    }
+
+    keys(idx) = key
+
+    size += 1
+
+    true
+  }
+
+  /**
+    * Insert a key and puts the pointer carrying elements greater than the key at its right side
+    */
+  def insertRight(key: K, ptr: Block[T, K, V])(implicit comp: Ordering[K]): Boolean = {
+
+    if(isFull) return false
+
+    val (_, idx) = find(key)(comp)
+
+    for(i<-(size until idx by -1)){
+      keys(i) = keys(i-1)
+
+      setChild(i+1, pointers(i))
+    }
+
+    keys(idx) = key
+    setChild(idx + 1, ptr)
+
+    size += 1
+
+    true
+  }
+
+  /**
+    * Insert a key and puts the pointer carrying elements lesser than the key at its left side
+    */
+  def insertLeft(key: K, ptr: Block[T, K, V])(implicit comp: Ordering[K]): Boolean = {
+
+    if(isFull) return false
+
+    val (_, idx) = find(key)(comp)
+
+    for(i<-size until idx by -1){
+      keys(i) = keys(i-1)
+
+      setChild(i+1, pointers(i))
+    }
+
+    setChild(idx + 1, pointers(idx))
+
+    keys(idx) = key
+    setChild(idx, ptr)
+
+    size += 1
+
+    true
+  }
+
+  def remove(idx: Int): Boolean = {
+
+    size -= 1
+
+    for(i<-idx until size){
+      keys(i) = keys(i+1)
+
+      setChild(i+1, pointers(i+2))
+    }
+
+    true
+  }
+
+  /**
+    * Special case for the left rotation or right borrowing
+    */
+  def removeRight(idx: Int): K = {
+
+    val k = keys(idx)
+
+    size -= 1
+
+    for(i<-idx until size){
+      keys(i) = keys(i+1)
+      setChild(i, pointers(i+1))
+    }
+
+    setChild(size, pointers(size+1))
+
+    k
+  }
+
+  def removeAndGet(idx: Int): K = {
+    val key = keys(idx)
+    remove(idx)
+    key
+  }
+
+  def left: Option[MetaBlock[T, K, V]] = {
+    parent match {
+      case None => None
+      case Some(parent) =>
+        val idx = pos - 1
+        if(idx >= 0) Some(parent.pointers(idx).asInstanceOf[MetaBlock[T, K, V]]) else None
+    }
+  }
+
+  def right: Option[MetaBlock[T, K, V]] = {
+    parent match {
+      case None => None
+      case Some(parent) =>
+        val idx = pos + 1
+        if(idx <= parent.size) Some(parent.pointers(idx).asInstanceOf[MetaBlock[T, K, V]]) else None
+
+    }
+  }
+
+  def inOrder: Seq[K] = keys.slice(0, size)
+
+  override def isFull = size == MAX
+
+  override def toString = s"""[${keys.slice(0, size).mkString(",")}]"""
+
+}
Index: src/test/scala/btree/DataBlockSpec.scala
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/test/scala/btree/DataBlockSpec.scala	(date 1530758126000)
+++ src/test/scala/btree/DataBlockSpec.scala	(date 1530758126000)
@@ -0,0 +1,68 @@
+package btree
+
+import java.util.UUID
+import java.util.concurrent.ThreadLocalRandom
+
+import org.scalatest.FlatSpec
+
+class DataBlockSpec extends FlatSpec {
+
+  "data block data must" should "be equal to test data" in {
+
+    implicit val comp = new Ordering[Int] {
+      override def compare(x: Int, y: Int): Int = x - y
+    }
+
+    val MAX_VALUE = 1000000
+    val n = 100
+
+    val ORDER = 1000
+    val MIN = ORDER - 1
+    val MAX = ORDER*2 - 1
+
+    val block = new DataBlock[String, Int, Int](UUID.randomUUID.toString, MIN, MAX)
+    val data = scala.collection.mutable.ArrayBuffer[Int]()
+
+    val rand = ThreadLocalRandom.current()
+
+    for(i<-0 until n){
+
+      rand.nextInt match {
+        case n if n % 2 == 0 =>
+
+          val k = rand.nextInt(1, MAX_VALUE)
+
+          println(s"\nINSERTING ${k}...\n")
+
+          if(block.insert(k -> k)){
+            data += k
+          }
+
+        case n if data.size > 0 && n % 3 == 0 =>
+
+          val pos = rand.nextInt(0, data.size)
+          val k = data(pos)
+
+          println(s"\nREMOVING ${k}...\n")
+
+          if(block.removeByKey(k)){
+            data -= k
+          }
+
+        case _ =>
+
+      }
+
+    }
+
+    val sorted = data.sorted
+    val bsorted = block.inOrder
+
+    println(s"\nDATA: ${sorted}\n")
+    println(s"\nBLOCK: ${bsorted}\n")
+
+    assert(bsorted.equals(sorted))
+
+  }
+
+}
Index: src/test/scala/btree/DeletionSpec.scala
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/test/scala/btree/DeletionSpec.scala	(date 1530758126000)
+++ src/test/scala/btree/DeletionSpec.scala	(date 1530758126000)
@@ -0,0 +1,83 @@
+package btree
+
+import java.util.concurrent.ThreadLocalRandom
+
+import org.scalatest.FlatSpec
+
+class DeletionSpec extends FlatSpec {
+
+  "btree data" should "be equal test data" in {
+
+    implicit val comp = new Ordering[Int] {
+      override def compare(x: Int, y: Int): Int = x - y
+    }
+
+    val rand = ThreadLocalRandom.current()
+
+    val iterations = 1
+
+    for(j<-0 until iterations){
+
+      val MAX_VALUE = 1000
+      val n = 10000
+
+      //val DATA_ORDER = rand.nextInt(2, 10)
+      //val META_ORDER = rand.nextInt(2, 10)
+
+      val DATA_ORDER = 2
+      val META_ORDER = 2
+
+      val index = new Index[String, Int, Int](DATA_ORDER, META_ORDER)
+      /*val data = scala.collection.mutable.ArrayBuffer[Int]()
+
+      for(i<-0 until 24){
+        val k = rand.nextInt(1, MAX_VALUE)
+
+        if(index.insert(k, k)){
+          data += k
+        }
+      }*/
+
+      val data = scala.collection.mutable.ArrayBuffer(44, 90, 118, 125, 153, 199, 275, 296, 304, 316, 324,
+        412, 482, 559, 560, 639, 671, 740, 743, 797, 818, 833, 878, 894)
+
+      for(i<-0 until data.size){
+        val k = data(i)
+        index.insert(k, k)
+      }
+
+      index.prettyPrint()
+
+      val removed = scala.collection.mutable.ArrayBuffer[Int]()
+
+      for(i<-0 until data.size){
+        val pos = rand.nextInt(0, data.size)
+        val k = data(pos)
+
+        if(!removed.contains(k)){
+
+          index.remove(k)
+          data -= k
+
+          removed += k
+        }
+      }
+
+      println(s"\ndata: ${data}\n")
+      println(s"\nremoved: ${removed}\n")
+
+      val sorted = data.sorted
+      val bsorted = index.inOrder
+
+      println(s"\nDATA: ${sorted}\n")
+      println(s"\nINDEX: ${bsorted}\n")
+
+      index.prettyPrint()
+
+      assert(bsorted.equals(sorted))
+
+    }
+
+  }
+
+}
Index: src/test/scala/btree/InsertionSpec.scala
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/test/scala/btree/InsertionSpec.scala	(date 1530758126000)
+++ src/test/scala/btree/InsertionSpec.scala	(date 1530758126000)
@@ -0,0 +1,53 @@
+package btree
+
+import java.util.concurrent.ThreadLocalRandom
+
+import org.scalatest.FlatSpec
+
+class InsertionSpec extends FlatSpec {
+
+  "btree data" should "be equal test data" in {
+
+    implicit val comp = new Ordering[Int] {
+      override def compare(x: Int, y: Int): Int = x - y
+    }
+
+    val rand = ThreadLocalRandom.current()
+
+    val iterations = 1
+
+    for(j<-0 until iterations){
+
+      val MAX_VALUE = 100000
+      val n = 100000
+
+      val DATA_ORDER = rand.nextInt(2, 100)
+      val META_ORDER = rand.nextInt(2, 100)
+
+      val index = new Index[String, Int, Int](DATA_ORDER, META_ORDER)
+      val data = scala.collection.mutable.ArrayBuffer[Int]()
+
+      for(i<-0 until n){
+        val k = rand.nextInt(1, MAX_VALUE)
+
+        index.insert(k, k)
+
+        if(!data.contains(k)){
+          data += k
+        }
+
+      }
+
+      val sorted = data.sorted
+      val bsorted = index.inOrder
+
+      println(s"\nDATA: ${sorted}\n")
+      println(s"\nINDEX: ${bsorted}\n")
+
+      assert(bsorted.equals(sorted))
+
+    }
+
+  }
+
+}
Index: src/test/scala/btree/MainSpec.scala
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/test/scala/btree/MainSpec.scala	(date 1530758126000)
+++ src/test/scala/btree/MainSpec.scala	(date 1530758126000)
@@ -0,0 +1,53 @@
+package btree
+
+import java.util.concurrent.ThreadLocalRandom
+
+import org.scalatest.FlatSpec
+
+class MainSpec extends FlatSpec {
+
+  "btree data" should "be equal test data" in {
+
+    implicit val comp = new Ordering[Int] {
+      override def compare(x: Int, y: Int): Int = x - y
+    }
+
+    val rand = ThreadLocalRandom.current()
+
+    val iterations = 1
+
+    for (j <- 0 until iterations) {
+
+      val MAX_VALUE = 100000
+      val n = 10000
+
+      val DATA_ORDER = rand.nextInt(2, 100)
+      val META_ORDER = rand.nextInt(2, 100)
+
+      val index = new Index[String, Int, Int](DATA_ORDER, META_ORDER)
+      val data = scala.collection.mutable.ArrayBuffer[Int]()
+
+      for (i <- 0 until n) {
+        val k = rand.nextInt(1, MAX_VALUE)
+
+        index.insert(k, k)
+
+        if (!data.contains(k)) {
+          data += k
+        }
+
+      }
+      
+      val sorted = data.sorted
+      val bsorted = index.inOrder
+
+      println(s"\nDATA: ${sorted}\n")
+      println(s"\nINDEX: ${bsorted}\n")
+
+      assert(bsorted.equals(sorted))
+
+    }
+
+  }
+
+}
Index: src/test/scala/btree/RandomDeletionSpec.scala
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/test/scala/btree/RandomDeletionSpec.scala	(date 1530758126000)
+++ src/test/scala/btree/RandomDeletionSpec.scala	(date 1530758126000)
@@ -0,0 +1,70 @@
+package btree
+
+import java.util.concurrent.ThreadLocalRandom
+
+import org.scalatest.FlatSpec
+
+class RandomDeletionSpec extends FlatSpec {
+
+  "btree data" should "be equal test data" in {
+
+    implicit val comp = new Ordering[Int] {
+      override def compare(x: Int, y: Int): Int = x - y
+    }
+
+    val rand = ThreadLocalRandom.current()
+
+    val iterations = 100
+
+    for(j<-0 until iterations){
+
+      val MAX_VALUE = 1000
+      val n = 10000
+
+      val DATA_ORDER = rand.nextInt(2, 10)
+      val META_ORDER = rand.nextInt(2, 10)
+
+      val index = new Index[String, Int, Int](DATA_ORDER, META_ORDER)
+      val data = scala.collection.mutable.ArrayBuffer[Int]()
+
+      for(i<-0 until n){
+
+        rand.nextInt match {
+          case n if n % 2 == 0 =>
+
+            val k = rand.nextInt(1, MAX_VALUE)
+
+            index.insert(k, k)
+
+            if(!data.contains(k)){
+              data += k
+            }
+
+          case n if n % 3 == 0 && data.size > 0 =>
+
+            val pos = rand.nextInt(0, data.size)
+            val k = data(pos)
+
+            index.remove(k)
+            data -= k
+
+          case _ =>
+        }
+
+      }
+
+      val sorted = data.sorted
+      val bsorted = index.inOrder
+
+      println(s"\nDATA: ${sorted}\n")
+      println(s"\nINDEX: ${bsorted}\n")
+
+      //index.prettyPrint()
+
+      assert(bsorted.equals(sorted))
+
+    }
+
+  }
+
+}
Index: src/test/scala/btree/TwoLevelDeletionSpec.scala
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/test/scala/btree/TwoLevelDeletionSpec.scala	(date 1530758126000)
+++ src/test/scala/btree/TwoLevelDeletionSpec.scala	(date 1530758126000)
@@ -0,0 +1,64 @@
+package btree
+
+import java.util.concurrent.ThreadLocalRandom
+
+import org.scalatest.FlatSpec
+
+class TwoLevelDeletionSpec extends FlatSpec {
+
+  "btree data" should "be equal test data" in {
+
+    implicit val comp = new Ordering[Int] {
+      override def compare(x: Int, y: Int): Int = x - y
+    }
+    
+    val rand = ThreadLocalRandom.current()
+
+    val iterations = 1
+
+    for(j<-0 until iterations){
+
+      val MAX_VALUE = 1000
+      val n = 10000
+
+      //val DATA_ORDER = rand.nextInt(2, 10)
+      //val META_ORDER = rand.nextInt(2, 10)
+
+      val DATA_ORDER = 2
+      val META_ORDER = 2
+
+      val index = new Index[String, Int, Int](DATA_ORDER, META_ORDER)
+      //val data = scala.collection.mutable.ArrayBuffer[Int]()
+
+      val data = scala.collection.mutable.ArrayBuffer(700, 888, 196, 371, 42, 317, 471, 403, 589)
+
+      for(i<-0 until data.size){
+        val k = data(i)
+        index.insert(k, k)
+      }
+
+      val remove = Seq(700, 471, 403, 317, 196, 888, 42, 589, 371)
+
+      for(i<-0 until remove.size){
+
+        val k = remove(i)
+        index.remove(k)
+        data -= k
+
+      }
+
+      println(s"\ndata: ${data}\n")
+
+      val sorted = data.sorted
+      val bsorted = index.inOrder
+
+      println(s"\nDATA: ${sorted}\n")
+      println(s"\nINDEX: ${bsorted}\n")
+
+      assert(bsorted.equals(sorted))
+
+    }
+
+  }
+
+}
